'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = RequestStateReducer;

var _immutable = require('immutable');

var initialState = (0, _immutable.Map)();

/**
 * Keeps fetching and error state in a global redux property "async", which is an immutable.js Map
 * It tracks state on actions ending with _FETCH, _ERROR or _RECEIVE
 * Variables are uppercase snakes and match the consts for fetch and error
 * XXX_FETCH is a boolean indicating if that action is currently requesting info (or undefined before any actions have been dispatched)
 * XXX_ERROR is either { status, message } if an error has occured, or is null otherwise
 * ^ really only useful for ensuring that a complete list of objects has been received when using ordered maps for collections. You won't know whether your list is complete or partial without this
 * e.g. state.async.LEARNING_PLAN_FETCH
 *
 * This listens to all actions and tracks the fetching and error states of all in a generic way. Async state data is kept under the `async` key in redux.
 * Fetching state is kept in `state.async.<FETCH_ACTION>` and will either be `true` if the action is currently fetching or a falsey value otherwise. `<FETCH_ACTION>` refers to the name (string) of the fetch action, such as `USER_GET_FETCH`.
 * Error state is kept in `state.async.<ERROR_ACTION>` and will either be an error like `{status: <status code>, message: <message>}`, or `null` otherwise. `<ERROR_ACTION>` refers to the name (string) of the error action, such as `USER_GET_ERROR`.
 * Actions follow a strict naming convention, each ending in either `_FETCH`, `_RECEIVE` or `_ERROR`. This allows the AsyncStateReducer to listen to the various actions and keep track of async state.
 *
 * @exports RequestStateReducer
 * @type {reducer}
 */
function RequestStateReducer() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	var _ref = arguments[1];
	var type = _ref.type,
	    payload = _ref.payload;


	if (!type) {
		return state;
	}

	var actionName = type.replace(/(_FETCH|_ERROR|_RECEIVE)$/g, '');

	if (/_FETCH$/g.test(type)) {
		return state.set(actionName + '_FETCH', true).set(actionName + '_ERROR', null);
	}

	if (/_ERROR$/g.test(type)) {
		var status = payload.status,
		    message = payload.message;

		return state.set(actionName + '_FETCH', false).set(actionName + '_ERROR', {
			status: status,
			message: message
		});
	}

	if (/_RECEIVE$/g.test(type)) {
		return state.set(actionName + '_FETCH', false).set(actionName + '_ERROR', null);
	}

	return state;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXF1ZXN0U3RhdGVSZWR1Y2VyLmpzIl0sIm5hbWVzIjpbIlJlcXVlc3RTdGF0ZVJlZHVjZXIiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsInR5cGUiLCJwYXlsb2FkIiwiYWN0aW9uTmFtZSIsInJlcGxhY2UiLCJ0ZXN0Iiwic2V0Iiwic3RhdHVzIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBcUJ3QkEsbUI7O0FBckJ4Qjs7QUFFQSxJQUFNQyxlQUFlLHFCQUFyQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQmUsU0FBU0QsbUJBQVQsR0FBb0U7QUFBQSxLQUF2Q0UsS0FBdUMsdUVBQS9CRCxZQUErQjtBQUFBO0FBQUEsS0FBaEJFLElBQWdCLFFBQWhCQSxJQUFnQjtBQUFBLEtBQVZDLE9BQVUsUUFBVkEsT0FBVTs7O0FBRWxGLEtBQUcsQ0FBQ0QsSUFBSixFQUFVO0FBQ1QsU0FBT0QsS0FBUDtBQUNBOztBQUVELEtBQU1HLGFBQWFGLEtBQUtHLE9BQUwsQ0FBYSw0QkFBYixFQUEyQyxFQUEzQyxDQUFuQjs7QUFFQSxLQUFHLFdBQVdDLElBQVgsQ0FBZ0JKLElBQWhCLENBQUgsRUFBMEI7QUFDekIsU0FBT0QsTUFDTE0sR0FESyxDQUNFSCxVQURGLGFBQ3NCLElBRHRCLEVBRUxHLEdBRkssQ0FFRUgsVUFGRixhQUVzQixJQUZ0QixDQUFQO0FBR0E7O0FBRUQsS0FBRyxXQUFXRSxJQUFYLENBQWdCSixJQUFoQixDQUFILEVBQTBCO0FBQUEsTUFDbEJNLE1BRGtCLEdBQ0NMLE9BREQsQ0FDbEJLLE1BRGtCO0FBQUEsTUFDVkMsT0FEVSxHQUNDTixPQURELENBQ1ZNLE9BRFU7O0FBRXpCLFNBQU9SLE1BQ0xNLEdBREssQ0FDRUgsVUFERixhQUNzQixLQUR0QixFQUVMRyxHQUZLLENBRUVILFVBRkYsYUFFc0I7QUFDZkksaUJBRGU7QUFFZkM7QUFGZSxHQUZ0QixDQUFQO0FBTUE7O0FBRUQsS0FBRyxhQUFhSCxJQUFiLENBQWtCSixJQUFsQixDQUFILEVBQTRCO0FBQzNCLFNBQU9ELE1BQ0xNLEdBREssQ0FDRUgsVUFERixhQUNzQixLQUR0QixFQUVMRyxHQUZLLENBRUVILFVBRkYsYUFFc0IsSUFGdEIsQ0FBUDtBQUdBOztBQUVELFFBQU9ILEtBQVA7QUFDQSIsImZpbGUiOiJSZXF1ZXN0U3RhdGVSZWR1Y2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtNYXB9IGZyb20gJ2ltbXV0YWJsZSc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IE1hcCgpO1xuXG4vKipcbiAqIEtlZXBzIGZldGNoaW5nIGFuZCBlcnJvciBzdGF0ZSBpbiBhIGdsb2JhbCByZWR1eCBwcm9wZXJ0eSBcImFzeW5jXCIsIHdoaWNoIGlzIGFuIGltbXV0YWJsZS5qcyBNYXBcbiAqIEl0IHRyYWNrcyBzdGF0ZSBvbiBhY3Rpb25zIGVuZGluZyB3aXRoIF9GRVRDSCwgX0VSUk9SIG9yIF9SRUNFSVZFXG4gKiBWYXJpYWJsZXMgYXJlIHVwcGVyY2FzZSBzbmFrZXMgYW5kIG1hdGNoIHRoZSBjb25zdHMgZm9yIGZldGNoIGFuZCBlcnJvclxuICogWFhYX0ZFVENIIGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoYXQgYWN0aW9uIGlzIGN1cnJlbnRseSByZXF1ZXN0aW5nIGluZm8gKG9yIHVuZGVmaW5lZCBiZWZvcmUgYW55IGFjdGlvbnMgaGF2ZSBiZWVuIGRpc3BhdGNoZWQpXG4gKiBYWFhfRVJST1IgaXMgZWl0aGVyIHsgc3RhdHVzLCBtZXNzYWdlIH0gaWYgYW4gZXJyb3IgaGFzIG9jY3VyZWQsIG9yIGlzIG51bGwgb3RoZXJ3aXNlXG4gKiBeIHJlYWxseSBvbmx5IHVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhIGNvbXBsZXRlIGxpc3Qgb2Ygb2JqZWN0cyBoYXMgYmVlbiByZWNlaXZlZCB3aGVuIHVzaW5nIG9yZGVyZWQgbWFwcyBmb3IgY29sbGVjdGlvbnMuIFlvdSB3b24ndCBrbm93IHdoZXRoZXIgeW91ciBsaXN0IGlzIGNvbXBsZXRlIG9yIHBhcnRpYWwgd2l0aG91dCB0aGlzXG4gKiBlLmcuIHN0YXRlLmFzeW5jLkxFQVJOSU5HX1BMQU5fRkVUQ0hcbiAqXG4gKiBUaGlzIGxpc3RlbnMgdG8gYWxsIGFjdGlvbnMgYW5kIHRyYWNrcyB0aGUgZmV0Y2hpbmcgYW5kIGVycm9yIHN0YXRlcyBvZiBhbGwgaW4gYSBnZW5lcmljIHdheS4gQXN5bmMgc3RhdGUgZGF0YSBpcyBrZXB0IHVuZGVyIHRoZSBgYXN5bmNgIGtleSBpbiByZWR1eC5cbiAqIEZldGNoaW5nIHN0YXRlIGlzIGtlcHQgaW4gYHN0YXRlLmFzeW5jLjxGRVRDSF9BQ1RJT04+YCBhbmQgd2lsbCBlaXRoZXIgYmUgYHRydWVgIGlmIHRoZSBhY3Rpb24gaXMgY3VycmVudGx5IGZldGNoaW5nIG9yIGEgZmFsc2V5IHZhbHVlIG90aGVyd2lzZS4gYDxGRVRDSF9BQ1RJT04+YCByZWZlcnMgdG8gdGhlIG5hbWUgKHN0cmluZykgb2YgdGhlIGZldGNoIGFjdGlvbiwgc3VjaCBhcyBgVVNFUl9HRVRfRkVUQ0hgLlxuICogRXJyb3Igc3RhdGUgaXMga2VwdCBpbiBgc3RhdGUuYXN5bmMuPEVSUk9SX0FDVElPTj5gIGFuZCB3aWxsIGVpdGhlciBiZSBhbiBlcnJvciBsaWtlIGB7c3RhdHVzOiA8c3RhdHVzIGNvZGU+LCBtZXNzYWdlOiA8bWVzc2FnZT59YCwgb3IgYG51bGxgIG90aGVyd2lzZS4gYDxFUlJPUl9BQ1RJT04+YCByZWZlcnMgdG8gdGhlIG5hbWUgKHN0cmluZykgb2YgdGhlIGVycm9yIGFjdGlvbiwgc3VjaCBhcyBgVVNFUl9HRVRfRVJST1JgLlxuICogQWN0aW9ucyBmb2xsb3cgYSBzdHJpY3QgbmFtaW5nIGNvbnZlbnRpb24sIGVhY2ggZW5kaW5nIGluIGVpdGhlciBgX0ZFVENIYCwgYF9SRUNFSVZFYCBvciBgX0VSUk9SYC4gVGhpcyBhbGxvd3MgdGhlIEFzeW5jU3RhdGVSZWR1Y2VyIHRvIGxpc3RlbiB0byB0aGUgdmFyaW91cyBhY3Rpb25zIGFuZCBrZWVwIHRyYWNrIG9mIGFzeW5jIHN0YXRlLlxuICpcbiAqIEBleHBvcnRzIFJlcXVlc3RTdGF0ZVJlZHVjZXJcbiAqIEB0eXBlIHtyZWR1Y2VyfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZXF1ZXN0U3RhdGVSZWR1Y2VyKHN0YXRlID0gaW5pdGlhbFN0YXRlLCB7dHlwZSwgcGF5bG9hZH0pIHtcblxuXHRpZighdHlwZSkge1xuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXG5cdGNvbnN0IGFjdGlvbk5hbWUgPSB0eXBlLnJlcGxhY2UoLyhfRkVUQ0h8X0VSUk9SfF9SRUNFSVZFKSQvZywgJycpO1xuXG5cdGlmKC9fRkVUQ0gkL2cudGVzdCh0eXBlKSkge1xuXHRcdHJldHVybiBzdGF0ZVxuXHRcdFx0LnNldChgJHthY3Rpb25OYW1lfV9GRVRDSGAsIHRydWUpXG5cdFx0XHQuc2V0KGAke2FjdGlvbk5hbWV9X0VSUk9SYCwgbnVsbCk7XG5cdH1cblxuXHRpZigvX0VSUk9SJC9nLnRlc3QodHlwZSkpIHtcblx0XHRjb25zdCB7c3RhdHVzLCBtZXNzYWdlfSA9IHBheWxvYWQ7XG5cdFx0cmV0dXJuIHN0YXRlXG5cdFx0XHQuc2V0KGAke2FjdGlvbk5hbWV9X0ZFVENIYCwgZmFsc2UpXG5cdFx0XHQuc2V0KGAke2FjdGlvbk5hbWV9X0VSUk9SYCwge1xuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcblx0fVxuXG5cdGlmKC9fUkVDRUlWRSQvZy50ZXN0KHR5cGUpKSB7XG5cdFx0cmV0dXJuIHN0YXRlXG5cdFx0XHQuc2V0KGAke2FjdGlvbk5hbWV9X0ZFVENIYCwgZmFsc2UpXG5cdFx0XHQuc2V0KGAke2FjdGlvbk5hbWV9X0VSUk9SYCwgbnVsbCk7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGU7XG59XG4iXX0=